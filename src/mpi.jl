# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


# This file holds MPI-related functionality

############################ MPI-related ##########################

function start_mpi(comm=MPI.COMM_WORLD)
    MPI.Initialized() || MPI.Init()
    rank = MPI.Comm_rank(comm)
    println("MPI initialized. This is rank $(rank) of $(MPI.Comm_size(comm)).")
    #rank == 0 || redirect_stdout(open("/dev/null", "w"))
    return rank, comm
end


function get_rank(comm=MPI.COMM_WORLD)
    MPI.Initialized() || return 0
    return MPI.Comm_rank(comm)
end


# concatenate_mpi_arr(): This function collects the xyzv's generated by each MPI
# process into one single xyzv on the rank=0 process, and concatenates along
# the last axis.
function concatenate_mpi_arr(x::AbstractVector{T}, comm=MPI.COMM_WORLD) where {T}
    x_r = convert(Vector{T}, x)

    if !MPI.Initialized()
        return x_r
    end

    #test_mpi()
    if get_rank() == 0
        # use our own
        for rank=1:MPI.Comm_size(comm)-1
            len, status = MPI.Recv(Int64, rank, 0, comm)
            println("Receiving $len from rank $rank (status=$status)...")
            x_remote = typeof(x_r)(undef, len)
            status = MPI.Recv!(x_remote, rank, 1, comm)
            println("Received $len from rank $rank (status=$status).")
            append!(x_r, x_remote)
        end
        return x_r
    else
        rank = get_rank(comm)
        println("Rank $(rank) sending $(length(x_r)) to rank 0...")
        MPI.Send(Int64(length(x_r)), 0, 0, comm)
        MPI.Send(x_r, 0, 1, comm)
        println("Rank $(rank) sent $(length(x_r)) to rank 0.")
        return fill(T(NaN), 0)
    end
end

function concatenate_mpi_arr(x, comm=MPI.COMM_WORLD)
    shape = size(x)
    x = reshape(x, :)
    x = concatenate_mpi_arr(x, comm)
    return reshape(x, shape[1:end-1]..., :)
end


function test_mpi()
    @show MPI.Initialized()
    start_mpi()
    comm = MPI.COMM_WORLD
    rank = MPI.Comm_rank(comm)
    @show MPI.Initialized()

    len = rand(1:9)
    x = Float32[rank + i/10 for i=1:len]

    sleep(rand())
    @show rank, len, x

    if rank == 0
        for i=1:MPI.Comm_size(comm)-1
            len, status = MPI.Recv(Int64, i, 0, comm)
            xremote = Array{Float32}(undef, len)
            MPI.Recv!(xremote, i, 1, comm)
            @show rank,i,len,xremote
        end
    else
        MPI.Send(length(x), 0, 0, comm)
        MPI.Send(x, 0, 1, comm)
    end
    @show "done",rank
end


function test_pencilffts(Nmesh=512)
    MPI.Initialized() || MPI.Init()
    rank = MPI.Comm_rank(comm)
    println("MPI initialized. This is rank $(rank) of $(MPI.Comm_size(comm)).")


    println("FFTW:")
    p0 = plan_fft!(A; flags=FFTW.MEASURE)
    A = rand(ComplexF64, 256, 256, 256)
    fft!(A)
    fftshift!(A)


    println("PencilFFTs.jl:")

    proc_dims = MPI.Dims_create(MPI.Comm_size(comm), zeros(Int, 2))
    proc_dims = tuple(Int64.(proc_dims)...)
    transform = Transforms.RFFT()
    @show proc_dims typeof(proc_dims)

    # the `fftw_flags` argument causes segfaults
    @time p1 = PencilFFTPlan((Nmesh,Nmesh,Nmesh), transform, proc_dims, comm)#; fftw_flags=FFTW.MEASURE)

    @time B = allocate_input(p1)
    @time rand!(B)
    @time C = p1 * B
    @time D = p1 \ C
end

