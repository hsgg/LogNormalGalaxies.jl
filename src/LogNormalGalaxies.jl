# The purpose of this package is to provide a quick way to generate a mock
# galaxy catalog.
#
# This version can use either FFTW or PencilFFTs.jl to distribute the density
# field over several nodes. PencilFFTs.jl, in turn, uses MPI for this task.


module LogNormalGalaxies

export simulate_galaxies,
       read_galaxies,
       write_galaxies


include("Splines.jl")

using Printf
using FFTW
using MPI
using PencilFFTs
using Statistics
using PoissonRandom
using TwoFAST
using Random


using .Splines

using QuadOsc
#using QuadGK

#using PyPlot


estimate_memory(N::Integer) = estimate_memory([N,N,N])
function estimate_memory(nxyz::Array)
    nfloats = 9 * prod(nxyz)
    memory = nfloats * sizeof(Float64)
    return memory
end


j0(x) = sinc(x/π)


function xicalc00_quadosc(fn, r)
    I,E = quadosc(k -> k^2 * fn(k) * j0(k*r), 0, Inf, n->π*n/r)
    #I,E = quadgk(k -> k^2 * fn(k) * j0(k*r), 0, Inf)
    I,E = (I,E) ./ (2 * π^2)
    #@show r,I
    return I
end


# PencilFFTs.jl needs 'allocate_input()', but FFTW doesn't provide it:
function PencilFFTs.allocate_input(plan::FFTW.FFTWPlan)
    T = eltype(plan)
    return Array{T}(undef, size(plan))
end


function plan_with_fftw(nxyz)
    return plan_rfft(Array{Float64}(undef, nxyz...))
end

function plan_with_pencilffts(nxyz)
    rank, comm = start_mpi()

    proc_dims = tuple(MPI.Dims_create!(MPI.Comm_size(comm), zeros(Int, 2))...)
    transform = Transforms.RFFT()
    @show proc_dims

    @time rfftplan = PencilFFTPlan((nxyz...,), transform, proc_dims, comm)
    return rfftplan
end

#default_plan = plan_with_fftw
default_plan = plan_with_pencilffts


Base.deepcopy(pa::PencilArray) = PencilArray(pencil(pa), deepcopy(parent(pa)))


PencilFFTs.pencil(arr::AbstractArray) = size(arr)


allocate_array(shape, type::DataType) = Array{type}(undef, shape)

allocate_array(pen::Pencil, type::DataType) = begin
    @show pen typeof(pen)
    return PencilArray{type}(undef, Pencil(pen))
end


PencilFFTs.global_view(arr::AbstractArray) = arr


PencilFFTs.range_local(arr::AbstractArray) = begin
    r = ()
    for s in size_global(arr)
        r = (r..., 1:s)
    end
    return r
end


PencilFFTs.size_global(arr::AbstractArray) = size(arr)

PencilFFTs.sizeof_global(arr::AbstractArray) = sizeof(arr)


############## MPI stuff ###########33

function start_mpi(comm=MPI.COMM_WORLD)
    MPI.Initialized() || MPI.Init()
    rank = MPI.Comm_rank(comm)
    println("This is $(rank) of $(MPI.Comm_size(comm))")
    #rank == 0 || redirect_stdout(open("/dev/null", "w"))
    return rank, comm
end


function get_rank(comm=MPI.COMM_WORLD)
    MPI.Initialized() || return 0
    return MPI.Comm_rank(comm)
end


# concatenate_mpi_arr(): This function collects the xyzv's generated by each MPI
# process into one single xyzv on the rank=0 process, and concatenates along
# the last axis.
function concatenate_mpi_arr(x::AbstractVector, T=Float32, comm=MPI.COMM_WORLD)
    test_mpi()
    if get_rank(comm) == 0
        # use our own
        x_out = Array{T}(x)
        # receive from all others
        for rank=1:MPI.Comm_size(comm)-1
            len, status = MPI.Recv(Int64, rank, 0, comm)
            @show rank,len
            x_remote = typeof(x_out)(undef, len)
            status = MPI.Recv!(x_remote, rank, 1, comm)
            append!(x_out, x_remote)
            @show rank,"recv done"
        end
        return x_out
    else
        x_r = Array{T}(x)
        # send size to rank = 0
        MPI.Send(Int64(length(x_r)), 0, 0, comm)
        # send galaxies to rank = 0
        MPI.Send(x_r, 0, 1, comm)
        @show get_rank(),"send done"
        return fill(NaN32, 0)
    end
end

function concatenate_mpi_arr(x, T=Float32, comm=MPI.COMM_WORLD)
    shape = size(x)
    x = reshape(x, :)
    x = concatenate_mpi_arr(x, T, comm)
    return reshape(x, shape[1:end-1]..., :)
end


function test_mpi()
    start_mpi()
    comm = MPI.COMM_WORLD
    rank = MPI.Comm_rank(comm)

    len = rand(1:9)
    x = Float32[rank + i/10 for i=1:len]

    sleep(rand())
    @show rank, len, x

    if rank == 0
        for i=1:MPI.Comm_size(comm)-1
            len, status = MPI.Recv(Int64, i, 0, comm)
            xremote = Array{Float32}(undef, len)
            MPI.Recv!(xremote, i, 1, comm)
            @show rank,i,len,xremote
        end
    else
        MPI.Send(length(x), 0, 0, comm)
        MPI.Send(x, 0, 1, comm)
    end
    @show "done",rank
end



#################### calculate P_G(k) ###########################
function pk_to_pkG(pkfn)
    ## Notes: xicalc is fast here, quadosc is too slow for large r. However,
    ## xicalc has some noise at large r. Therefore, later we need to use
    ## quadosc as it is more robust in dealing with that noise.

    r1, xi1 = xicalc(pkfn, 0, 0; kmin=1e-10, kmax=1e10, r0=1e-5, N=2^15, q=2.0)
    #r2, xi2 = xicalc(pkfn, 0, 0; kmin=1e-25, kmax=1e25, r0=1e-25, N=4096, q=2.0)
    #r3 = 10.0 .^ range(-4, 3.7, length=1000)
    #xi3 = xicalc00_quadosc.(pkfn, r3)

    r, xi = r1, xi1

    #close("all")

    #figure()
    #plot(r1,xi1, "b", label=L"\xi(r)")
    #plot(r1,-xi1, "b--")
    #plot(r3,xi3, "g", label=L"\xi(r)")
    #plot(r3,-xi3, "g--")
    #xscale("log")
    #yscale("log")
    #legend()

    sel = @. 1e-5 <= r <= 1e7
    r = r[sel]
    xi = xi[sel]

    #sel2 = @. 1e-5 <= r2 <= 1e7
    #r2 = r2[sel2]
    #xi2 = xi2[sel2]

    xiG = @. log1p(xi)
    xiGfn = Spline1D(r, xiG, extrapolation=Splines.powerlaw)
    #xiG2 = @. log1p(xi2)
    #xiG3 = @. log1p(xi3)
    #xiG3fn = Spline1D(r3, xiG3, extrapolation=Splines.powerlaw)

    #figure()
    ##plot(r,xi, "k", label=L"\xi(r)")
    ##plot(r,-xi, "k--")
    ##plot(r,xiG, "b", label=L"\xi_G(r)")
    ##plot(r,-xiG, "b--")
    #plot(r,r.^3 .* xi, "k", label=L"r^3 \xi(r)")
    #plot(r,-r.^3 .* xi, "k--")
    ##plot(r2,r2.^3 .* xi2, "0.75")
    ##plot(r2,-r2.^3 .* xi2, c="0.75", ls="--")
    #plot(r,r.^3 .* xiG, "b", label=L"r^3 \xi_G(r)")
    #plot(r,-r.^3 .* xiG, "b--")
    #plot(r3,r3.^3 .* xiG3, "g")
    #plot(r3,-r3.^3 .* xiG3, "g--")
    #xscale("log")
    #yscale("log")
    #xlabel(L"r")
    #legend()

    #k1, pkG1 = xicalc(xiGfn, 0, 0; kmin=1e-10, kmax=1e10, r0=1e-10, N=2^18, q=1.5)
    #k2, pkG2 = xicalc(xiGfn, 0, 0; kmin=1e-10, kmax=1e10, r0=1e-5, N=2^18, q=1.5)
    k3 = 10.0 .^ range(-5, 2, length=200)
    pkG3 = xicalc00_quadosc.(xiGfn, k3)
    #pkG1 .*= (2π)^3
    #pkG2 .*= (2π)^3
    pkG3 .*= (2π)^3

    k, pkG = k3, pkG3

    #figure()
    #plot(k, pkfn.(k), "k", L"P(k)")
    #plot(k1,pkG1, "b", label=L"$P_G(k)$")
    #plot(k1,-pkG1, "b--")
    ##plot(k2,pkG2, "g", label=L"$P_G(k)$")
    ##plot(k2,-pkG2, "g--")
    #plot(k3,pkG3, "r", label=L"$P_G(k)$")
    #plot(k3,-pkG3, "r--")
    #xscale("log")
    #yscale("log")
    ##ylim(1e-14, 1e5)
    #legend()

    @show k[1], pkG[1]

    # the extremes lead to overflow
    sel = @. (pkG > 0)
    k = k[sel][3:end-2]
    pkG = pkG[sel][3:end-2]
    @show k[1], pkG[1]

    sel = @. 1e-5 <= k <= 1e2
    k = k[sel]
    pkG = pkG[sel]
    @show k[1], pkG[1]

    pkGfn = Spline1D(k, pkG, extrapolation=Splines.powerlaw)
    @show pkGfn.([0.0, 1e-4])
    return k, pkGfn
end


#################### draw deltak ###########################

function draw_phases(rfftplan)
    deltar = allocate_input(rfftplan)
    @show size(deltar),length(deltar)
    randn!(parent(deltar))
    @show mean(deltar),var_global(deltar)
    @assert !isnan(mean(deltar))

    @time deltak_phases = rfftplan * deltar
    @show mean(deltak_phases)
    @assert !isnan(mean(deltak_phases))

    @time @. deltak_phases /= abs(deltak_phases)
    @show mean(deltak_phases)
    @assert !isnan(mean(deltak_phases))
    @show sizeof_global(deltak_phases)/1024^3
    @show sizeof(rfftplan)
    return deltak_phases
end


function calc_kmode(nx, ny, nz, kF, pencil_δk)
    nx2 = div(nx,2) + 1
    ny2 = div(ny,2) + 1
    nz2 = div(nz,2) + 1
    #kmode = PencilArray{Float64}(undef, Pencil(pencil_δk, Float64))  # allocate uninitialized array
    kmode = allocate_array(pencil_δk, Float64)
    kmode_global = global_view(kmode)
    localrange = range_local(kmode)
    for k=localrange[3], j=localrange[2], i=localrange[1]
        ikx = i - 1
        iky = j <= ny2 ? j-1 : j-1-ny
        ikz = k <= nz2 ? k-1 : k-1-nz
        kmode_global[i,j,k] = kF * √(ikx^2 + iky^2 + ikz^2)
    end
    return kmode
end


####################### calculate volocity field #################
function calculate_velocities_faH(deltak, kF)
    nx2, ny, nz = size_global(deltak)
    ny2 = div(ny,2) + 1
    nz2 = div(nz,2) + 1
    vkx = deepcopy(deltak)
    vky = deepcopy(deltak)
    vkz = deepcopy(deltak)
    deltak_global = global_view(deltak)
    vkx_global = global_view(vkx)
    vky_global = global_view(vky)
    vkz_global = global_view(vkz)
    localrange = range_local(deltak)
    for k=localrange[3], j=localrange[2], i=localrange[1]
        ikx = i - 1
        iky = j <= ny2 ? j-1 : j-1-ny
        ikz = k <= nz2 ? k-1 : k-1-nz
        ikmode = √(ikx^2 + iky^2 + ikz^2)
        if ikmode == 0
            vkx_global[i,j,k] = 0
            vky_global[i,j,k] = 0
            vkz_global[i,j,k] = 0
        else
            vk = im/ikmode^2/kF*deltak_global[i,j,k]
            vkx_global[i,j,k] = ikx*vk
            vky_global[i,j,k] = iky*vk
            vkz_global[i,j,k] = ikz*vk
        end
    end
    return vkx, vky, vkz
end


##################### draw galaxies ###########################
function draw_galaxies_with_velocities(deltar, vx, vy, vz, Ngalaxies, Δx=1.0)
    T = Float32
    rsd = !(vx == vy == vz == 0)
    nx, ny, nz = size_global(deltar)
    Navg = Ngalaxies / (nx * ny * nz)
    xyzv = T[]
    deltar_global = global_view(deltar)
    if rsd
        vx_global = global_view(vx)
        vy_global = global_view(vy)
        vz_global = global_view(vz)
    end
    localrange = range_local(deltar)
    @time for k=localrange[3], j=localrange[2], i=localrange[1]
        Nthiscell = pois_rand((1 + deltar_global[i,j,k]) * Navg)
        for n=1:Nthiscell
            x = i - 1 + rand()
            y = j - 1 + rand()
            z = k - 1 + rand()
            push!(xyzv, x*Δx)
            push!(xyzv, y*Δx)
            push!(xyzv, z*Δx)
            if rsd
                push!(xyzv, vx_global[i,j,k])
                push!(xyzv, vy_global[i,j,k])
                push!(xyzv, vz_global[i,j,k])
            else
                push!(xyzv, T(0))
                push!(xyzv, T(0))
                push!(xyzv, T(0))
            end
        end
    end
    @time xyzv_out = reshape(xyzv, 6, :)
    return xyzv_out
end


######################### make galaxies file ######################

# write galaxies in same format as lognormal_galaxies
function write_galaxies(fname, LLL, xyzv)
    Ngalaxies = size(xyzv,2)
    fout = open(fname, "w")
    write(fout, Array{Float64}(collect(LLL)))
    write(fout, Int64(Ngalaxies))
    write(fout, Array{Float32}(xyzv))
    close(fout)
end


# read galaxies in same format as lognormal_galaxies
function read_galaxies(fname; ncol=6)
    fin = open(fname, "r")
    Lx, Ly, Lz = read!(fin, Array{Float64}(undef, 3))
    Ngalaxies = read(fin, Int64)
    xyzv = read!(fin, Array{Float32,2}(undef, ncol, Ngalaxies))
    close(fin)
    return (Lx, Ly, Lz), xyzv
end


# var_global(): Calculate variance of the given array, taking care of proper
# handling of distributed arrays such as PencilArrays.
function var_global(arr, comm=MPI.COMM_WORLD)
    n = length(arr)
    μ = mean(arr)
    v = var(arr)
    if MPI.Initialized()
        nn = MPI.Allgather(n, comm)
        μμ = MPI.Allgather(μ, comm)
        vv = MPI.Allgather(v, comm)
        n = sum(nn)
        μ = sum(@. nn / n * μμ)
        v = sum(@. (nn - 1) / (n - 1) * vv + nn / (n - 1) * (μμ - μ)^2)
    end
    return v
end


function calculate_sigmaGsq(pk)
end


function pixel_window!(deltak, nxyz)
    #nx = size(deltak)  # nx[1] is actually nx/2
    #nx2 = (nx[1], nx[2] ÷ 2 + 1, nx[3] ÷ 2 + 1)
    nx2 = @. nxyz ÷ 2 + 1
    p = 1  # NGP:1, CIC:2, TSC:3
    for k=1:size(deltak,3), j=1:size(deltak,2), i=1:size(deltak,1)
        ikx = i - 1
        iky = j - 1 - (j <= nx2[2] ? 0 : nxyz[2])
        ikz = k - 1 - (k <= nx2[3] ? 0 : nxyz[3])
        Wmesh = (j0(π*ikx/nxyz[1]) * j0(π*iky/nxyz[2]) * j0(π*ikz/nxyz[3]))^p
        deltak[i,j,k] /= Wmesh
    end
end


################## simulate_galaxies() ##################
# Here are multiple functions called 'simulate_galaxies()'. They only differ in
# their interface.

# simulate galaxies
function simulate_galaxies(nxyz, Lxyz, Ngalaxies, pk, kF, Δx, b, faH; rfftplan=default_plan(nxyz))
    nx, ny, nz = nxyz
    Lx, Ly, Lz = Lxyz
    Volume = Lx * Ly * Lz

    println("Convert to log-normal...")
    #kln = readdlm("$root/data/fog_r1000_pkG.dat")[:,1]
    #pkGln = readdlm("$root/data/fog_r1000_pkG.dat")[:,2]
    kGm, pkGm = pk_to_pkG(pk)
    kGg, pkGg = pk_to_pkG(k -> b^2 * pk(k))

    @show pkGm.([0.0,1.0])
    @show pkGg.([0.0,1.0])

    println("Draw random phases...")
    deltak_phases = draw_phases(rfftplan)
    @show get_rank(),deltak_phases[1,1,1],mean(deltak_phases)
    println("Calculate kmode...")
    @time kmode = calc_kmode(nx, ny, nz, kF, pencil(deltak_phases))
    @show get_rank(),kmode[1,1,1],mean(kmode)
    Volume = (2π / kF)^3
    println("Calculate deltak{m,g}...")
    @time deltakm = deepcopy(deltak_phases)
    @time deltakg = deltak_phases
    @show get_rank(),deltakm[1,1,1],mean(deltakm)
    @show get_rank(),deltakg[1,1,1],mean(deltakg)
    @time @. deltakm *= √(pkGm(kmode) * Volume)
    @time @. deltakg *= √(pkGg(kmode) * Volume)
    ##@time pixel_window!(deltakm, nxyz)
    #@time pixel_window!(deltakg, nxyz)
    deltak_phases = nothing
    kmode = nothing
    @show get_rank(),deltakm[1,1,1],mean(deltakm)
    @show get_rank(),deltakg[1,1,1],mean(deltakg)
    println("Calculate deltar{m,g}...")
    @time deltarm = rfftplan \ deltakm
    @time deltarg = rfftplan \ deltakg
    @show get_rank(),"interim",deltarm[1,1,1],mean(deltakm)
    @show get_rank(),"interim",deltarg[1,1,1],mean(deltakg)
    @time @. deltarm *= (nx*ny*nz) / Volume
    @time @. deltarg *= (nx*ny*nz) / Volume
    @show get_rank(),deltarm[1,1,1],mean(deltakm)
    @show get_rank(),deltarg[1,1,1],mean(deltakg)
    deltakg = nothing
    @show mean(deltarm),std(deltarm)
    @show extrema(deltarm)
    @show mean(deltarg),std(deltarg)
    @show extrema(deltarg)

    # G -> δ
    println("Transform G → δ...")
    σGm² = var_global(deltarm)
    σGg² = var_global(deltarg)
    @time @. deltarm = exp(deltarm - σGm²/2) - 1
    @time @. deltarg = exp(deltarg - σGg²/2) - 1
    @show σGm² σGg²
    @show mean(deltarm),std(deltarm)
    @show extrema(deltarm)
    @show mean(deltarg),std(deltarg)
    @show extrema(deltarg)

    # calculate velocity field
    if faH != 0
        println("Calculate deltakm...")
        @time deltakm = rfftplan * deltarm
        @time @. deltakm *= Volume / (nx*ny*nz)
        deltarm = nothing
        println("Calculate v⃗(k⃗)...")
        @time vkx, vky, vkz = calculate_velocities_faH(deltakm, kF)
        deltakm = nothing  # free memory
        println("Calculate v⃗(r⃗)...")
        @time vx = rfftplan \ vkx
        @time @. vx *= faH * (nx*ny*nz) / Volume
        vkx = nothing  # free memory
        @time vy = rfftplan \ vky
        @time @. vy *= faH * (nx*ny*nz) / Volume
        vky = nothing  # free memory
        @time vz = rfftplan \ vkz
        @time @. vz *= faH * (nx*ny*nz) / Volume
        vkz = nothing  # free memory
    else
        vx = vy = vz = 0
    end

    println("Draw galaxies...")
    @time xyzv = draw_galaxies_with_velocities(deltarg, vx, vy, vz, Ngalaxies, Δx)
    return xyzv
end


function simulate_galaxies(nbar, Lbox, pk; nmesh=256, bias=1.0, f=0.0,
        rfftplanner=default_plan)
    aH = 1
    b = bias
    L = Lbox
    Ngalaxies = ceil(Int, L^3 * nbar)

    n = nmesh
    kF = 2π/L
    Δx = L/n

    nxyz = n, n, n
    Lxyz = L, L, L

    rfftplan = rfftplanner(nxyz)

    @time xyzv = simulate_galaxies(nxyz, Lxyz, Ngalaxies, pk, kF, Δx, b, f;
                                   rfftplan=rfftplan)
    xyz = @. xyzv[1:3,:] - Float32(L / 2)
    v = xyzv[4:6,:]
    return xyz, v
end


end


# vim: set sw=4 et sts=4 :
